1- `val` ile `var` arasındaki fark nedir?

    'val' ile 'var' keyword'leri değişken tanımlamak için kullanılır.
     'val' keyword'ü, read-only (sadece okunabilir) değişkenler tanımlamamıza
     olanak tanırken, 'var' keyword'ü ise mutable (değeri değişebilen) değişkenler
     tanımlamamıza olanak tanır. Aralarındaki temel fark budur.

=================================================================================

2- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan?
 Bunu neden yapmak isteriz? Örnek bir senaryo verin.

    Bir 'var' değişkenin set'ini private yaparak 'val' gibi davranmasını sağlayabiliriz ama bunu sadece
     class'larda yapabiliriz çünkü fonksiyon içerisindeki değişkenlere sadece o fonksiyon içerisinden
     erişebiliriz. Bu yüzden de private set yapmanın bir mantığı kalmaz.

     Örn.
        var name = "Doğaç"
            private set  
     
    Peki oluşturduğumuz değişkenin set'ini neden private yapmak isteriz? Çünkü aynı class içerisinde 
     değiştirebiliriz fakat farklı class'larda sadece okuyabiliriz. Örnek senaryo olarak bir Person
     class'ımızın olduğunu düşünelim. Bu class'ın içerisinde de age isimli bir değişken var ve biz
     bu age değişkeninin sadece Person class'ında değiştirilebilmesini istiyoruz. Bu durumda private set
     kullanabiliriz. Peki neden değişkeni ilk başta private olarak tanımlamıyoruz? Çünkü farklı fonksiyonlarda
     bu age değişkenini okumak/kullanıcıya göstermek isteyebiliriz.

=================================================================================

3- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın.
 `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

    Immutable (Değişmez) ve read-only (salt okunur) kavramları birbirlerine çok benzerdir, fakat aralarında küçük
     bir fark vardır. Immutable'da, değişkenin değeri ilk tanımlamadan sonra hiçbir zaman, hiçbir şekilde
     değiştirilemez. Read-only'de ise, değişkenin değeri bazı durumlarda değiştirilebilir.
     'val' değişkenlerin immutable değil de read-only olmasının sebebi getter'ının olmasıdır. Değişkenin değerini
     getter kısmında verirsek, başka bir fonksiyondan da bu değişkeni değiştirebiliriz.

     Örn.
        fun main() {

            val math = Math()

            println(math.result)

            math.number2 = 50

            println(math.result)
        }

        class Math() {

            var number1 = 10
            var number2 = 20

            val result get() = number1 + number2
        }
    
    Bu kodda, main fonksiyonunda ilk başta sonucu bastırıyoruz ve val olarak tanımlanan 'result' değişkeninin
     değerinin 30 olduğunu görüyoruz. 'number2' değişkeninin değerini 50 ile değiştirip tekrardan sonucu
     bastırıyoruz ve bu sefer 'result' değişkeninin değerinin 60 olduğunu görüyoruz. Bu yüzden 'val' değişkenler
     immutable değil read-only'dir.

=================================================================================

4- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

    Type inference (Tip çıkarımı) kavramı, bir değişken tanımlarken dilin, değişken tipini otomatik olarak tahmin
     etmesidir. Bu bizi gereksiz koddan kurtarır ve kodumuzu okunur kılar. Eğer değişkenler nullable olacaksa veya
     değişkenin değeri sonradan atanacaksa kesin olarak tip belirtmemiz gerekir.

=================================================================================

5- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi?
 Arka planda neler oluyor?

    Kotlin'de tüm değişkenlerin/veri tiplerinin sınıf olarak bulunmasının sebebi, o değişkene ait fonksiyonları
     kullanabilmemiz içindir. Bu durum primitive type (ilkel tip) olmadıkları anlamına gelmez. Kotlin'de veri
     tipleri class olarak bulunuyor fakat proje derlenirken veya çalışırken bu class'lar primitive tiplere
     dönüştürülüyor. Eğer bir değişken, "primitive tipe dönüştürülebilen" bir veri yapısına atanıyorsa (Örn. Int)
     veya "primitive tipe dönüştürülebilen" bir veri yapısı içeren fonksiyon çağrılıyorsa bunlar, 
     compile time'da (derleme zamanı) primitive tip'e dönüştürülür. Eğer bir String'den, "primitive tipe
     dönüştürülebilen" bir veri yapısına (Örn. Int) 'as' keyword'ü ile cast işlemi yapılıyorsa veya String tipinden
     Int tipine bir dönüşüm yapılıyorsa (Örn. val number = "5".toInt()) bunlar runtime'da (çalışma zamanı) gerçekleşir.

=================================================================================

6- "Tip Güvenliği" (Type Safety) kavramını açıklayın.

    Type safety (tip güvenliği), program çalışırken alınabilecek tip hatalarına karşı koruma sağlayan bir özelliktir.
     Derleme sırasında her değişkenin ve ifadenin tipi kontrol edilir ve yalnızca uyumlu tipler arasındaki işlemlere
     izin verilir. Bu işlemin derleme sırasında yapılmasının sebebi ise program çalışırken, tip hatası yüzünden
     programın çökmemesini engellemek içindir. Type safety konusuna örnek olarak şu verilebilir; bir topla fonksiyonumuz
     var ve parametre olarak 'a: Int' ve 'b: Int' parametrelerini alıyor ve fonksiyon geriye 'Int' döndürüyor.
     Bu fonksiyonu, main fonksiyonunda çağırıp, değer olarak birine int birine double değer atarsak, program 
     derleme sırasında hata verecektir çünkü 'Double' ile 'Int'in toplamı sonuç olarak 'Double' döndürecektir.
     Topla fonksiyonu bizden 'Int' bir değer döndürmemizi beklediği için de hata verecektir. Bu hatayı kullanıcıya
     yansıtmamak için de derleme sırasında verir. Program hiç çalışmadan hata vermiş olur.

=================================================================================